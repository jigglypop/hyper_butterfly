# 3. 디코딩: `Packed64` 시드 → 파라미터 (`src/decoding.rs`)

이 문서에서는 단일 `u64` 시드에 압축된 정보를 다시 사람이 읽을 수 있는 파라미터(`DecodedParams` 구조체)로 복원하는 디코딩 과정을 설명합니다.

---

### `Packed64::decode()`

```rust
impl Packed64 {
    pub fn decode(&self) -> DecodedParams {
        // ... (구현)
    }
}
```

-   **역할**: `self` (즉, `Packed64` 시드)가 가진 64비트 정수 값을 해석하여, 각 필드에 해당하는 파라미터를 추출하고 `DecodedParams` 구조체를 만들어 반환합니다.
-   **핵심 과정**: 인코딩의 역순으로 진행됩니다.
    1.  **비트 언패킹 (Bit Unpacking)**: 비트 마스크(`&`)와 `SHIFT` (`>>`) 연산을 사용하여, `u64`의 특정 위치에서 원하는 비트 조각들을 추출합니다.
    2.  **역양자화 (Dequantization)**: 추출된 정수 값들을 다시 원래의 `f32` 실수 값으로 변환합니다. 예를 들어, `r_bits`는 20비트 최댓값으로 나누어 `[0, 1)` 범위의 실수가 됩니다.
    3.  **구조체 생성**: 복원된 모든 파라미터를 `DecodedParams` 구조체에 담아 반환합니다.

### 특수 필드 처리

#### `log2_c` (3비트 부호 있는 정수)

`log2_c` 필드는 3비트만으로 음수와 양수를 모두 표현해야 합니다. 이를 위해 **2의 보수(2's complement)** 표현법이 사용됩니다.

```rust
// 3비트 부호있는 정수 복원 (-4 ~ +3)
let log2_c = if (log2_c_bits & 0x4) != 0 { // 최상위 비트(MSB)가 1이면 음수
    (log2_c_bits as i8) | -8 // 0b100 -> -4, 0b101 -> -3, ...
} else {
    log2_c_bits as i8      // 0b000 -> 0, 0b001 -> 1, ...
};
```
-   `log2_c_bits`에서 최상위 비트(세 번째 비트, `0x4`)가 1인지 확인합니다.
-   1이면 음수이므로, 나머지 비트들을 `i8`로 변환한 후 상위 비트들을 1로 채워(`| -8`) 올바른 음수 값을 만듭니다.
-   0이면 양수이므로, 그대로 `i8`로 변환합니다.
-   이를 통해 3비트(`000`~`111`)만으로 -4부터 +3까지의 값을 표현할 수 있습니다.

이 디코딩 과정을 통해, 압축된 시드는 다시 행렬 생성을 위한 명시적인 파라미터들로 변환되어 `compute_weight` 함수에서 사용될 준비를 마칩니다. 