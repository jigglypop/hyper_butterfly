## 3. 방법론: 리만 기하학 기저 인코딩 (RBE)

본 장에서는 `Reality Stone`의 핵심 방법론인 **리만 기하학 기저 인코딩(Riemannian Basis Encoding, RBE)** 의 이론적 배경, 핵심 알고리즘, 그리고 구현 세부 사항을 상세히 기술한다. RBE는 거대한 가중치 행렬 $W \in \mathbb{R}^{m \times n}$를, 기하학적 의미를 담은 **기저 청사진(Basis Blueprint)** 과 미세 오차를 보정하는 **잔차(Residual)** 로 분해하여 극단적인 압축을 달성한다.

### 3.1. RBE의 핵심 원리: 기하학적 분해와 크로네커 델타 선택

RBE는 신경망 가중치 행렬 $W$의 각 행벡터 $w_i \in \mathbb{R}^n$를, **(1) 방향(Direction)**과 **(2) 크기(Magnitude)**의 두 요소로 분해하는 것에서 출발한다. 이 분해는 유한한 기저 벡터 집합 $\{b_j\}_{j=1}^B$에 대한 이산적 선택 과정으로 모델링되며, 이는 **크로네커 델타(Kronecker Delta)** 함수를 통해 수학적으로 명확하게 표현될 수 있다.

원본 가중치 행벡터 $w_i$는 다음과 같이 근사치 $w_{\text{approx}, i}$와 잔차 $w_{\text{res}, i}$의 합으로 정확하게 표현된다.

$$ w_i = w_{\text{approx}, i} + w_{\text{res}, i} $$

여기서 근사치 $w_{\text{approx}, i}$는 기저 벡터 중 하나를 선택하고, 그 기저 벡터에 기하학적 스케일을 적용하여 계산된다.

$$ w_{\text{approx}, i} = s_i \cdot \left( \sum_{j=1}^{B} \delta_{j, \text{idx}_i} b_j \right) = s_i \cdot b_{\text{idx}_i} $$

-   **$\delta_{j, \text{idx}_i}$ (크로네커 델타):** 기저 선택 메커니즘의 핵심. $j = \text{idx}_i$일 때만 1이고, 그 외에는 0이다. 비트필드의 `idx` 필드가 이 `idx_i` 값을 지정하며, 이는 수많은 기저 벡터 중 단 하나를 선택하는 '하드 어텐션(hard attention)'과 유사하게 동작한다.
-   **$b_{\text{idx}_i}$ (선택된 기저 벡터):** 크로네커 델타에 의해 선택된, $w_i$의 주된 방향을 나타내는 단위 벡터.
-   **$s_i$ (기하학적 스케일):** 비트필드에 인코딩된 파라미터 `(cat, sub, d, amp, amp_fine)`로부터 계산되는 스칼라 값. 이는 선택된 기저 방향으로의 크기를 결정하며, 특정 리만 기저 함수 $\mathcal{F}$를 통해 계산된다 ($s_i = \mathcal{F}(\text{params}_i)$).

이러한 분해를 통해, 원래의 가중치 행벡터 $w_i$는 **(기저 벡터 인덱스, 기저 함수 타입, 함수 파라미터)** 라는 압축된 정보(비트필드)와, 근사 오차를 보정하는 작은 잔차 벡터 $w_{\text{res}, i}$로 완벽하게 재구성될 수 있다.

### 3.2. 1단계 (인코딩): 기저 청사진과 잔차 생성

주어진 가중치 행렬 $W$를 RBE 형태로 인코딩하는 과정은 다음과 같다.

#### 3.2.1. 기저 청사진 생성 (The Blueprint)

$W$의 각 행 $w_i$에 대해, 다음을 수행하여 32비트 **비트 필드(Bitfield)** 를 생성한다.

1.  **최적 기저 탐색 ($\text{idx}_i$ 결정):** 미리 정의된 기저 벡터 테이블 $\{b_j\}$ 중에서 $w_i$와 가장 유사한(예: 코사인 유사도가 가장 높은) 기저 벡터 $b_{\text{idx}_i}$를 찾는다. 이 `idx_i`가 이 행의 **기저 인덱스**가 된다.
2.  **프로젝션 및 스케일 계산 ($s_i$ 결정):** $w_i$를 $b_{\text{idx}_i}$ 방향으로 투영하여, 그 크기를 가장 잘 표현하는 리만 기저 함수 $\mathcal{F}$와 그 파라미터(예: `amp`, `amp_fine` 등)를 결정한다. 이를 통해 스케일 값 $s_i$가 계산된다.
3.  **비트 필드 패킹:** 위에서 얻은 파라미터들을 다음의 32비트 구조에 패킹하여, $i$번째 행의 청사진 코드 `code_i`를 생성한다.

```
Bit:  31......22 21 20 19 18 17..10  09  08  07...0
      |----------|-----|-----|--------|---|---|------|
      | AMP_FINE | CAT | SUB |   IDX  | S | D | AMP  |
      |    10    |  2  |  2  |    8   | 1 | 1 |  8   |
```
*S: Sign bit*

이 코드의 배열이 **기저 청사진 행렬 $W_{\text{codes}}$** 이다.

#### 3.2.2. 잔차 계산 (The Residual)

청사진만으로 재구성된 근사 가중치 벡터 $w_{\text{approx}, i}$와 원본 벡터 $w_i$ 사이의 오차를 **잔차 벡터 $w_{\text{res}, i}$** 로 정의한다.

$$ w_{\text{res}, i} = w_i - w_{\text{approx}, i} = w_i - s_i \cdot b_{\text{idx}_i} $$

이 계산을 모든 행에 대해 수행하여 얻은 행렬이 **잔차 행렬 $W_{\text{res}}$** 이다.
$$ W_{\text{res}} = W - W_{\text{approx}} $$

$W_{\text{res}}$의 각 원소는 일반적으로 원본 $W$보다 훨씬 작은 값을 가지므로, FP8 또는 INT8과 같은 저정밀도 데이터 타입으로 양자화하여 저장할 수 있다. 이는 추가적인 압축 효과와 함께 최종 정확도를 보정하는 핵심적인 역할을 수행한다.

### 3.3. 리만 기저 함수 라이브러리

RBE의 표현력은 다양한 형태의 가중치 분포를 모델링할 수 있는 풍부한 기저 함수 라이브러리에서 나온다. 22비트 청사진의 `(CAT, SUB, D)` 코드는 총 64가지 함수를 선택할 수 있게 한다.

-   **Category 0: 푸앵카레 기하학 (CAT=0):** `tanh`, `sinh` 등 쌍곡 공간의 기본적인 매핑 함수. 계층 구조 표현에 유리하다.
-   **Category 1: 로렌츠 기하학 (CAT=1):** `sinh`, `cosh` 등 더 넓은 범위의 값을 표현. 동적 시스템 모델링에 적합하다.
-   **Category 2: 삼각 함수 (CAT=2):** `sin`, `cos` 등 주기적/위상적 패턴을 가진 가중치를 모델링하기 위한 함수. (미래 구현)
-   **Category 3: 특수 함수 (CAT=3):** `Bessel`, `Gaussian` 등 특정 복잡한 패턴을 표현하기 위한 실험적인 함수. (미래 구현)

*(전체 함수 목록은 부록 참조)*

### 3.4. 2단계 (디코딩 및 추론): 압축 상태에서 직접 추론

RBE의 가장 큰 장점은, 가중치 행렬 $W$를 전부 복원하지 않고 **압축된 $W_{\text{codes}}$와 저정밀도 $W_{\text{res}}$로부터 직접** 행렬-벡터 곱셈($y = xW^T$)을 수행하는 것이다.

출력 벡터의 $i$번째 요소 $y_i$는 입력 $x$와 $i$번째 가중치 행 $w_i$의 내적이다.
$$
\begin{aligned}
y_i &= x \cdot w_i^T \\
    &= x \cdot (w_{\text{approx}, i} + w_{\text{res}, i})^T \\
    &= (x \cdot w_{\text{approx}, i}^T) + (x \cdot w_{\text{res}, i}^T)
\end{aligned}
$$

1.  **청사진 추론 (Blueprint-based Inference):**
    $w_{\text{approx}, i}$에 크로네커 델타를 이용한 정의를 대입하면,
    $$
    \begin{aligned}
    x \cdot w_{\text{approx}, i}^T &= x \cdot (s_i \cdot b_{\text{idx}_i})^T \\
                               &= s_i \cdot (x \cdot b_{\text{idx}_i}^T)
    \end{aligned}
    $$
    이 수식은 거대한 행렬곱을 (1) 작은 기저 테이블과의 내적($x \cdot b_j^T$), (2) 인덱싱(크로네커 델타 선택), (3) 스칼라 곱으로 변환하여 연산량을 획기적으로 줄인다.

2.  **잔차 추론 (Residual-based Inference):**
    $x \cdot w_{\text{res}, i}^T$ 항은 표준적인 저정밀도 행렬-벡터 곱셈으로 효율적으로 계산된다.

#### 3.4.1. 통합 CUDA 커널

이 두 과정을 하나의 CUDA 커널에서 효율적으로 처리한다.

1.  **전처리 (공유 메모리 활용):** 입력 $x$와 기저 테이블 $\{b_j\}$의 내적 값 `dot_products[j] = x · b_j` 를 미리 계산하여 공유 메모리에 저장한다.
2.  **병렬 처리 루프:** 각 스레드가 출력의 한 요소 $y_i$를 담당한다.
    a. $i$번째 코드 `code_i`를 디코딩하여 `(idx, params)`를 얻는다.
    b. 스케일 값 $s_i = \mathcal{F}_i(\text{params}_i)$ 를 계산한다.
    c. 청사진 결과 $y_{\text{approx}, i} = s_i \cdot \text{dot_products}[\text{idx}_i]$ 를 계산한다.
    d. 잔차 결과 $y_{\text{res}, i} = x \cdot w_{\text{res}, i}$ 를 저정밀도 연산(DP4A 등)으로 계산한다.
    e. 최종 결과 $y_i = y_{\text{approx}, i} + y_{\text{res}, i}$ 를 저장한다.

이 접근법은 FLOP(연산량)과 메모리 대역폭을 동시에 최적화하여, 기존 방식 대비 3-4배의 실질적인 추론 가속을 달성한다.

### 3.5. 미래 구현 계획: 동적 위상 인코딩

현재 RBE는 기저 함수의 '크기(magnitude)'를 중심으로 인코딩하지만, 향후 버전에서는 '위상(phase)' 정보를 명시적으로 인코딩하는 메커니즘을 추가할 계획이다.

-   **복소수 및 쿼터니언 기저:** 가중치 공간을 복소수 또는 쿼터니언 공간으로 확장하여, 회전 및 위상 변환을 자연스럽게 모델링한다.
-   **위상 필드 추가:** 22비트 청사진에 위상 정보를 인코딩하는 추가 필드를 할당하여, 더 복잡하고 동적인 변환을 표현할 수 있도록 한다.

이는 특히 음성, RF 신호 처리, 양자 회로 시뮬레이션 등 위상 정보가 중요한 도메인에서 RBE의 적용 범위를 크게 확장할 것이다. 