# ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

Reality Stoneì˜ ë‚´ë¶€ êµ¬ì¡°ì™€ ì„¤ê³„ ì›ì¹™ì„ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

## ì „ì²´ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Python API Layer                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚   PoincarÃ©      â”‚  â”‚    Lorentz      â”‚  â”‚     Klein       â”‚â”‚
â”‚  â”‚   Layers        â”‚  â”‚    Layers       â”‚  â”‚    Layers       â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚              Core Operations (Mobius, etc.)                â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   PyO3 Bindings                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚            Rust-Python Interface                           â”‚â”‚
â”‚  â”‚         (Type conversion, Error handling)                  â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Rust Core                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚   CPU Kernels   â”‚  â”‚  CUDA Kernels   â”‚  â”‚   Memory Mgmt   â”‚â”‚
â”‚  â”‚                 â”‚  â”‚                 â”‚  â”‚                 â”‚â”‚
â”‚  â”‚ â€¢ PoincarÃ© Ops  â”‚  â”‚ â€¢ GPU PoincarÃ©  â”‚  â”‚ â€¢ Safe Alloc    â”‚â”‚
â”‚  â”‚ â€¢ Lorentz Ops   â”‚  â”‚ â€¢ GPU Lorentz   â”‚  â”‚ â€¢ Buffer Mgmt   â”‚â”‚
â”‚  â”‚ â€¢ Klein Ops     â”‚  â”‚ â€¢ GPU Klein     â”‚  â”‚ â€¢ Error Safety  â”‚â”‚
â”‚  â”‚ â€¢ Mobius Ops    â”‚  â”‚ â€¢ GPU Mobius    â”‚  â”‚                 â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ¦€ Rust ì½”ì–´ êµ¬ì¡°

### ë””ë ‰í† ë¦¬ êµ¬ì¡°

```
src/
â”œâ”€â”€ lib.rs                 # ë©”ì¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì§„ì…ì 
â”œâ”€â”€ layers/                # í•˜ì´í¼ë³¼ë¦­ ë ˆì´ì–´ êµ¬í˜„
â”‚   â”œâ”€â”€ mod.rs            # ë ˆì´ì–´ ëª¨ë“ˆ ì •ì˜
â”‚   â”œâ”€â”€ poincare.rs       # PoincarÃ© Ball ë ˆì´ì–´
â”‚   â”œâ”€â”€ lorentz.rs        # Lorentz ë ˆì´ì–´
â”‚   â”œâ”€â”€ klein.rs          # Klein ë ˆì´ì–´
â”‚   â”œâ”€â”€ mobius.rs         # Mobius ë³€í™˜
â”‚   â”œâ”€â”€ utils.rs          # ê³µí†µ ìœ í‹¸ë¦¬í‹°
â”‚   â””â”€â”€ cuda/             # CUDA êµ¬í˜„
â”‚       â”œâ”€â”€ poincare.cu   # PoincarÃ© CUDA ì»¤ë„
â”‚       â”œâ”€â”€ lorentz.cu    # Lorentz CUDA ì»¤ë„
â”‚       â”œâ”€â”€ klein.cu      # Klein CUDA ì»¤ë„
â”‚       â””â”€â”€ mobius.cu     # Mobius CUDA ì»¤ë„
â”œâ”€â”€ bindings/             # Python ë°”ì¸ë”©
â”‚   â”œâ”€â”€ mod.rs            # ë°”ì¸ë”© ëª¨ë“ˆ ì •ì˜
â”‚   â”œâ”€â”€ poincare.rs       # PoincarÃ© ë°”ì¸ë”©
â”‚   â”œâ”€â”€ lorentz.rs        # Lorentz ë°”ì¸ë”©
â”‚   â”œâ”€â”€ klein.rs          # Klein ë°”ì¸ë”©
â”‚   â””â”€â”€ mobius.rs         # Mobius ë°”ì¸ë”©
â””â”€â”€ ops/                  # ê¸°ë³¸ ì—°ì‚° (ë¯¸ë˜ í™•ì¥)
    â””â”€â”€ mod.rs
```

### í•µì‹¬ ì„¤ê³„ ì›ì¹™

#### 1. ë©”ëª¨ë¦¬ ì•ˆì „ì„±
```rust
// ëª¨ë“  ë©”ëª¨ë¦¬ ì ‘ê·¼ì€ Rustì˜ ì†Œìœ ê¶Œ ì‹œìŠ¤í…œìœ¼ë¡œ ë³´í˜¸
pub fn poincare_add_cpu(
    x: &Array2<f64>,
    y: &Array2<f64>,
    c: f64,
) -> Result<Array2<f64>, Box<dyn Error>> {
    // ì•ˆì „í•œ ë©”ëª¨ë¦¬ ì ‘ê·¼ ë³´ì¥
    let result = Array2::zeros(x.dim());
    // ... êµ¬í˜„
    Ok(result)
}
```

#### 2. ì—ëŸ¬ ì²˜ë¦¬
```rust
// ëª¨ë“  í•¨ìˆ˜ëŠ” Result íƒ€ì…ìœ¼ë¡œ ì—ëŸ¬ ì²˜ë¦¬
pub type HyperbolicResult<T> = Result<T, HyperbolicError>;

#[derive(Debug, thiserror::Error)]
pub enum HyperbolicError {
    #[error("Invalid curvature parameter: {0}")]
    InvalidCurvature(f64),
    #[error("Tensor dimension mismatch: expected {expected}, got {actual}")]
    DimensionMismatch { expected: usize, actual: usize },
    #[error("CUDA error: {0}")]
    CudaError(String),
}
```

#### 3. ì„±ëŠ¥ ìµœì í™”
```rust
// SIMD ìµœì í™” ì‚¬ìš©
use simba::simd::*;

// ë³‘ë ¬ ì²˜ë¦¬
use rayon::prelude::*;

pub fn parallel_poincare_add(
    x: &Array2<f64>,
    y: &Array2<f64>,
    c: f64,
) -> Array2<f64> {
    x.axis_iter(Axis(0))
        .into_par_iter()
        .zip(y.axis_iter(Axis(0)))
        .map(|(x_row, y_row)| {
            // ë³‘ë ¬ ì²˜ë¦¬ë¡œ ê° í–‰ ê³„ì‚°
            mobius_add_row(x_row, y_row, c)
        })
        .collect()
}
```

## ğŸ Python ë°”ì¸ë”© êµ¬ì¡°

### PyO3 ë°”ì¸ë”© íŒ¨í„´

```rust
// src/bindings/poincare.rs
use pyo3::prelude::*;
use numpy::{PyArray2, PyReadonlyArray2};

#[pyfunction]
pub fn poincare_ball_layer_cpu(
    u: PyReadonlyArray2<f64>,
    v: PyReadonlyArray2<f64>,
    c: f64,
    t: f64,
) -> PyResult<Py<PyArray2<f64>>> {
    // NumPy ë°°ì—´ì„ Rust ë°°ì—´ë¡œ ë³€í™˜
    let u_array = u.as_array();
    let v_array = v.as_array();
    
    // Rust í•¨ìˆ˜ í˜¸ì¶œ
    let result = crate::layers::poincare::poincare_ball_layer(
        &u_array, &v_array, c, t
    ).map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;
    
    // ê²°ê³¼ë¥¼ NumPy ë°°ì—´ë¡œ ë³€í™˜
    Ok(result.into_pyarray(py).to_owned())
}
```

### Python ë˜í¼ êµ¬ì¡°

```python
# python/reality_stone/layers/poincare.py
from torch.autograd import Function
from .. import _rust

class PoincareBallLayer(Function):
    @staticmethod
    def forward(ctx, u, v, c, t):
        # ì»¨í…ìŠ¤íŠ¸ ì €ì¥
        ctx.save_for_backward(u, v)
        ctx.c = c
        ctx.t = t
        
        # Rust í•¨ìˆ˜ í˜¸ì¶œ
        if u.is_cuda:
            return _rust.poincare_ball_layer_cuda(u, v, c, t)
        else:
            return _rust.poincare_ball_layer_cpu(u, v, c, t)
    
    @staticmethod
    def backward(ctx, grad_output):
        u, v = ctx.saved_tensors
        c, t = ctx.c, ctx.t
        
        # ì—­ì „íŒŒ ê³„ì‚°
        grad_u, grad_v = _rust.poincare_ball_layer_backward(
            grad_output, u, v, c, t
        )
        return grad_u, grad_v, None, None
```

## CUDA êµ¬í˜„ êµ¬ì¡°

### CUDA ì»¤ë„ êµ¬ì¡°

```cuda
// src/layers/cuda/poincare.cu
__global__ void poincare_add_kernel(
    const float* x,
    const float* y,
    float* result,
    int batch_size,
    int dim,
    float c
) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    int batch_idx = idx / dim;
    int feat_idx = idx % dim;
    
    if (batch_idx < batch_size && feat_idx < dim) {
        // Mobius ë§ì…ˆ ê³„ì‚°
        float x_val = x[idx];
        float y_val = y[idx];
        result[idx] = mobius_add_element(x_val, y_val, c);
    }
}
```

### ë©”ëª¨ë¦¬ ê´€ë¦¬

```rust
// CUDA ë©”ëª¨ë¦¬ ê´€ë¦¬
pub struct CudaBuffer<T> {
    ptr: *mut T,
    size: usize,
    _phantom: PhantomData<T>,
}

impl<T> CudaBuffer<T> {
    pub fn new(size: usize) -> Result<Self, CudaError> {
        let mut ptr = std::ptr::null_mut();
        unsafe {
            cuda_malloc(&mut ptr, size * std::mem::size_of::<T>())?;
        }
        Ok(CudaBuffer { ptr, size, _phantom: PhantomData })
    }
}

impl<T> Drop for CudaBuffer<T> {
    fn drop(&mut self) {
        unsafe {
            cuda_free(self.ptr);
        }
    }
}
```

## ğŸ”„ ë°ì´í„° í”Œë¡œìš°

### 1. Forward Pass
```
Python Input (torch.Tensor)
    â†“
NumPy Array (via .numpy())
    â†“
Rust ndarray
    â†“
CUDA Memory (if GPU)
    â†“
CUDA Kernel Execution
    â†“
Result Back to CPU
    â†“
Rust ndarray
    â†“
NumPy Array
    â†“
PyTorch Tensor
```

### 2. Backward Pass
```
Gradient (torch.Tensor)
    â†“
Saved Context (u, v, c, t)
    â†“
Rust Backward Function
    â†“
Computed Gradients
    â†“
Return (grad_u, grad_v, None, None)
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì•„í‚¤í…ì²˜

### í…ŒìŠ¤íŠ¸ ê³„ì¸µ

```
tests/
â”œâ”€â”€ unit/                 # ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_poincare.py  # PoincarÃ© ë ˆì´ì–´ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_lorentz.py   # Lorentz ë ˆì´ì–´ í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ test_mobius.py    # Mobius ì—°ì‚° í…ŒìŠ¤íŠ¸
â”œâ”€â”€ integration/          # í†µí•© í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_gradients.py # ê·¸ë˜ë””ì–¸íŠ¸ ì •í™•ì„± í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ test_cuda.py      # CUDA êµ¬í˜„ í…ŒìŠ¤íŠ¸
â””â”€â”€ benchmarks/           # ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
    â”œâ”€â”€ memory_test.py    # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í…ŒìŠ¤íŠ¸
    â””â”€â”€ speed_test.py     # ì†ë„ ë²¤ì¹˜ë§ˆí¬
```

## ë¹Œë“œ ì‹œìŠ¤í…œ

### Cargo.toml êµ¬ì¡°

```toml
[package]
name = "reality_stone"
version = "0.2.0"
edition = "2021"

[lib]
name = "_rust"
crate-type = ["cdylib"]

[dependencies]
pyo3 = { version = "0.19", features = ["extension-module"] }
numpy = "0.19"
ndarray = { version = "0.15", features = ["rayon"] }
rayon = "1.7"

[build-dependencies]
cc = "1.0"
glob = "0.3"

[features]
default = []
cuda = []
```

### ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸ (build.rs)

```rust
use std::env;
use cc::Build;

fn main() {
    #[cfg(feature = "cuda")]
    {
        let cuda_path = env::var("CUDA_HOME").expect("CUDA_HOME not set");
        
        // CUDA íŒŒì¼ ì»´íŒŒì¼
        let cu_files = glob::glob("src/layers/cuda/*.cu")
            .expect("Failed to read CUDA files")
            .collect::<Result<Vec<_>, _>>()
            .expect("Failed to collect CUDA files");
        
        for file in cu_files {
            Build::new()
                .cuda(true)
                .flag("-arch=sm_70")
                .include(format!("{}/include", cuda_path))
                .file(file)
                .compile("cuda_kernels");
        }
    }
}
```

## ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

### ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ

```rust
// ì—°ì† ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ ì‚¬ìš©
#[repr(C)]
pub struct Point {
    pub x: f64,
    pub y: f64,
}

// ìºì‹œ ì¹œí™”ì  ë°ì´í„° êµ¬ì¡°
pub struct BatchedPoints {
    pub data: Vec<f64>,  // [x1, y1, x2, y2, ...]
    pub batch_size: usize,
    pub dim: usize,
}
```

### SIMD ìµœì í™”

```rust
use simba::simd::f64x4;

pub fn vectorized_mobius_add(
    x: &[f64],
    y: &[f64],
    c: f64,
) -> Vec<f64> {
    let chunks = x.chunks_exact(4)
        .zip(y.chunks_exact(4))
        .map(|(x_chunk, y_chunk)| {
            let x_vec = f64x4::from_slice_unaligned(x_chunk);
            let y_vec = f64x4::from_slice_unaligned(y_chunk);
            mobius_add_simd(x_vec, y_vec, c)
        })
        .collect()
}
```

## ğŸ” ë””ë²„ê¹… ë° í”„ë¡œíŒŒì¼ë§

### ë””ë²„ê·¸ ë¹Œë“œ

```bash
# ë””ë²„ê·¸ ì •ë³´ í¬í•¨ ë¹Œë“œ
maturin develop --profile dev

# ë©”ëª¨ë¦¬ ë””ë²„ê¹…
valgrind --tool=memcheck python test_script.py

# CUDA ë””ë²„ê¹…
cuda-gdb python test_script.py
```

### í”„ë¡œíŒŒì¼ë§

```bash
# Rust í”„ë¡œíŒŒì¼ë§
cargo build --release --features cuda
perf record --call-graph=dwarf ./target/release/reality_stone

# Python í”„ë¡œíŒŒì¼ë§
python -m cProfile -o profile.stats test_script.py
```

ì´ ì•„í‚¤í…ì²˜ëŠ” ì„±ëŠ¥, ì•ˆì „ì„±, ìœ ì§€ë³´ìˆ˜ì„±ì„ ëª¨ë‘ ê³ ë ¤í•œ ì„¤ê³„ì…ë‹ˆë‹¤. ê° ë ˆì´ì–´ëŠ” ëª…í™•í•œ ì±…ì„ì„ ê°€ì§€ë©°, íƒ€ì… ì•ˆì „ì„±ê³¼ ì—ëŸ¬ ì²˜ë¦¬ë¥¼ í†µí•´ ì•ˆì •ì ì¸ ì‹œìŠ¤í…œì„ êµ¬ì¶•í–ˆìŠµë‹ˆë‹¤. 